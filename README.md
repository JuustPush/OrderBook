# OrderBook
Реализация биржевого стакана с помощью map,priority_queue и vector
# Реализация с контейнером map(multimap):
Сложность по времени:

Функция add_order: В худшем случае, при добавлении новой заявки, необходимо выполнить поиск в упорядоченном множестве заявок с помощью функции std::find_if. Сложность этого поиска в худшем случае составляет O(log n), где n - количество заявок. Также выполняется вставка новой заявки в множество с помощью функции emplace, что имеет амортизированную сложность O(1). Таким образом, общая сложность функции add_order в худшем случае составляет O(log n).

Функции change_order и remove_order: Как и в случае с add_order, эти функции также выполняют поиск в упорядоченном множестве с помощью функции std::find_if, что имеет сложность O(log n). После нахождения нужной заявки выполняется вставка новой заявки и удаление старой заявки, что имеет амортизированную сложность O(1). Таким образом, общая сложность функций change_order и remove_order в худшем случае составляет O(log n).

Функция display_top_10_orders: В этой функции выполняется сортировка списка заявок по цене дважды (раз для заявок на продажу, раз для заявок на покупку). Сортировка заявок требует O(n log n) операций, где n - количество заявок. Затем выполняется вывод первых 5 заявок на покупку и последних 5 заявок на продажу, что требует O(1) операций. Таким образом, общая сложность функции display_top_10_orders составляет O(n log n).

Функция measure_performance: В этой функции измеряется производительность функций add_order, change_order, remove_order и display_top_10_orders, поэтому ее сложность равна сумме сложностей этих функций.

Сложность по памяти:

Класс OrderBook: Занимаемая память зависит от количества заявок и их размера. Каждая заявка занимает память на хранение полей price, volume и type. Таким образом, общая память, занимаемая классом OrderBook, составляет O(n), где n - количество заявок.

Класс OrderBookTester: Занимаемая память в данном классе включает в себя объекты классов OrderBook и Order, а также локальные переменные для тестирования функций. В данном случае, память, занимаемая классом OrderBookTester, не зависит от количества заявок и ограничена фиксированным количеством объектов и локальных переменных, используемых во время тестирования.

В целом, общая сложность по памяти в данном коде составляет O(n), где n - количество заявок в классе OrderBook.

# Реализация с контейнером priority_queue:

По времени:
Метод add_order:

Для Buy: О(1) - добавление элемента в приоритетную очередь.
Для Sell: О(1) - добавление элемента в приоритетную очередь.
Метод find_order_buy:

О(n) - проход по приоритетной очереди для поиска элемента.
Метод find_order_sell:

О(n) - проход по приоритетной очереди для поиска элемента.
Метод change_order:

О(n) - проход по приоритетной очереди для поиска элемента.
О(log n) - удаление элемента из приоритетной очереди.
О(log n) - добавление элемента в приоритетную очередь.
Метод remove_order:

О(n) - проход по приоритетной очереди для поиска элемента.
О(log n) - удаление элемента из приоритетной очереди.
Метод display_top_10_orders:

О(1) - вывод 10 наилучших заявок из приоритетной очереди.
Метод measure_performance:

О(1) - измерение производительности для каждой операции.

По памяти:
OrderBook класс:

Память, выделенная под две очереди (приоритетные очереди buy_orders и sell_orders), будет зависеть от количества активных ордеров. В худшем случае, она может быть O(n), где n - количество ордеров в системе.
add_order метод:

Он использует константное количество дополнительной памяти для временных переменных и сообщений об ошибках, таким образом, его сложность по памяти составляет O(1).
find_order_buy и find_order_sell методы:

В этих методах используются временные структуры (temp), но их размер ограничен числом ордеров. Таким образом, их сложность по памяти также оценивается как O(1).
change_order метод:

Использует временные структуры для обновления и удаления ордеров, но их размер также ограничен числом ордеров. Сложность по памяти оценивается как O(1).
remove_order метод:

Использует временные структуры для удаления ордеров, но их размер также ограничен числом ордеров. Сложность по памяти оценивается как O(1).
display_top_10_orders метод:

Использует временные структуры (вектор) для сортировки и хранения результатов, но их размер ограничен 10 элементами. Сложность по памяти оценивается как O(1).
OrderBookTester класс:

Память, выделенная для объекта OrderBookTester, зависит от количества созданных тестовых ордеров и временных переменных для замера времени. В худшем случае, она может быть O(n), где n - количество созданных тестовых ордеров.
AddOrder, ChangeOrder, RemoveOrder и Display_top10 методы:

Используют константное количество дополнительной памяти для временных переменных и сообщений об ошибках, таким образом, их сложность по памяти составляет O(1).
measure_performance метод:

Использует временные переменные для замера времени, их количество константно. Сложность по памяти оценивается как O(1).

# Реализация с контейнером vector
По памяти: 
Добавление заявки (add_order):

Внутри функции есть два цикла, каждый из которых проходит по всем заявкам. Сложность этой части кода - O(N), где N - количество заявок.
Сортировка выполняется за O(N*log(N)).
Итоговая сложность - O(N + N*log(N)).
Изменение заявки (change_order):

Также есть два цикла, и сложность аналогична добавлению заявки - O(N + N*log(N)).
Удаление заявки (remove_order):

Здесь используется std::remove, который имеет сложность O(N).
Итоговая сложность - O(N).
Отображение лучших 10 заявок (display_top_10_orders):

Сначала выполняется сортировка, которая имеет сложность O(N*log(N)).
Затем производится вывод первых 10 элементов, что занимает O(1).
Итоговая сложность - O(N*log(N)).
Измерение производительности (measure_performance):

Здесь выполняются операции добавления, изменения, удаления и отображения заявок, каждая из которых имеет свою сложность.
Сложность по памяти:
Дополнительная память используется для хранения вектора orders, который хранит заявки. Сложность по памяти в основном зависит от количества заявок.
Распределение сложности:
По времени: О(N + N*log(N)) (где N - количество заявок).
По памяти: О(N), где N - количество заявок.
